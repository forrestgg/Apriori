/*
 * Copyright 2017 - 2019 Michael Rapp
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
package de.mrapp.apriori.modules

import de.mrapp.apriori.FrequentItemSets
import de.mrapp.apriori.Item
import de.mrapp.apriori.Transaction
import de.mrapp.apriori.datastructure.TransactionalItemSet
import de.mrapp.util.Condition.ensureAtLeast
import de.mrapp.util.Condition.ensureAtMaximum
import de.mrapp.util.datastructure.Pair
import org.slf4j.LoggerFactory
import java.util.*

/**
 * A module, which allows to find all frequent item sets, which occur in a data set. The data set
 * must contain multiple transactions of which each one consists of multiple items. Item sets are
 * considered frequent, if their support is greater or equal than a specific threshold.
 *
 * In order to search for frequent item sets efficiently, the algorithm exploits the
 * anti-monotonicity property of the support metric, which states, that an item set can only be
 * frequent, if all of its subsets are frequent as well. The other way around, the supersets of an
 * infrequent item set are also infrequent. Furthermore, the items must be sortable (e.g. by their
 * names) in order to generate possible candidates in an efficient way.
 *
 * @param <ItemType> The type of the items, which are processed by the algorithm
 * @author Michael Rapp
 * @since 1.0.0
 */
class FrequentItemSetMinerModule<ItemType : Item> : FrequentItemSetMiner<ItemType> {

    companion object {

        /**
         * The SLF4J logger, which is used by the module.
         */
        private val LOGGER = LoggerFactory.getLogger(FrequentItemSetMinerModule::class.java)

    }

    /**
     * Generates and returns all possible item sets that contain only one item. The item sets are
     * generated by iterating the transactions of a data set using a [iterable].
     *
     * @return A pair, which contains the generated item sets, as well as the number of
     * transactions, which have been iterated
     */
    private fun generateInitialItemSets(iterable: Iterable<Transaction<ItemType>>):
            Pair<Collection<TransactionalItemSet<ItemType>>, Int> {
        val itemSets = HashMap<Int, TransactionalItemSet<ItemType>>()
        var transactionCount = 0

        for (transaction in iterable) {
            for (item in transaction) {
                val itemSet = TransactionalItemSet<ItemType>()
                itemSet.add(item)
                val previous = itemSets.putIfAbsent(itemSet.hashCode(), itemSet)

                if (previous != null) {
                    previous.transactions[transactionCount] = transaction
                } else {
                    itemSet.transactions[transactionCount] = transaction
                }
            }

            transactionCount++
        }

        return Pair.create<Collection<TransactionalItemSet<ItemType>>, Int>(itemSets.values,
                transactionCount)
    }

    /**
     * Removes the [itemSets] that are not frequent, i.e. those that do not reach [minSupport], from
     * a specific collection. Calculating the support of the item sets requires the total number of
     * transactions [transactionCount] to be known.
     */
    private fun filterFrequentItemSets(itemSets: Collection<TransactionalItemSet<ItemType>>,
                                       transactionCount: Int, k: Int, minSupport: Double):
            List<TransactionalItemSet<ItemType>> {
        val frequentCandidates = ArrayList<TransactionalItemSet<ItemType>>(itemSets.size)

        for (candidate in itemSets) {
            if (k > 1) {
                val transactionSet = candidate.transactions.entries
                val transactions = HashMap<Int, Transaction<ItemType>>(transactionSet.size)

                for ((key, transaction) in transactionSet) {
                    val containedItemHashes = HashSet<Int>()

                    for (item in transaction) {
                        if (candidate.contains(item)) {
                            containedItemHashes.add(item.hashCode())
                        }
                    }

                    if (containedItemHashes.size >= candidate.size) {
                        transactions[key] = transaction
                    }
                }

                candidate.transactions = transactions
            }

            val occurrences = candidate.transactions.size
            val support = calculateSupport(transactionCount, occurrences)
            candidate.support = support

            if (support >= minSupport) {
                frequentCandidates.add(candidate)
            }
        }

        return frequentCandidates
    }

    /**
     * Creates item sets of the length k + 1 by combining [itemSets] of the length [k]. Two item
     * sets are only combined, if the first k - 1 items of both item sets are equal. Because the
     * items, that are contained by item sets, are always sorted, this enables to efficiently
     * generate all possible candidates, without generating any duplicates.
     */
    private fun combineItemSets(itemSets: List<TransactionalItemSet<ItemType>>,
                                k: Int): Collection<TransactionalItemSet<ItemType>> {
        if (itemSets.isNotEmpty()) {
            val combinedItemSets = HashSet<TransactionalItemSet<ItemType>>(
                    (1..itemSets.size).reduce { sum, i -> sum + i }, 1f)

            for (i in itemSets.indices) {
                for (j in i + 1 until itemSets.size) {
                    val itemSet1 = itemSets[i]
                    val itemSet2 = itemSets[j]
                    val iterator1 = itemSet1.iterator()
                    val iterator2 = itemSet2.iterator()
                    var itemToAdd: ItemType? = null
                    var index = 0

                    while (iterator1.hasNext() && iterator2.hasNext()) {
                        val item2 = iterator2.next()

                        if (index < k - 1) {
                            if (item2 != iterator1.next()) {
                                itemToAdd = null
                                break
                            }
                        } else {
                            itemToAdd = item2
                        }

                        index++
                    }

                    if (itemToAdd != null) {
                        val combinedItemSet = TransactionalItemSet(itemSet1)
                        combinedItemSet.add(itemToAdd)
                        combinedItemSet.transactions.putAll(itemSet2.transactions)
                        combinedItemSets.add(combinedItemSet)
                    }
                }
            }

            return combinedItemSets
        }

        return emptySet()
    }

    /**
     * Calculates and returns the support of an item.
     *
     * @param transactions The total number of available transactions. The number of transactions
     *                     must be at least 0
     * @param occurrences  The number of transactions, the item occurs in. The number of
     *                     transactions must be at least 0
     */
    private fun calculateSupport(transactions: Int, occurrences: Int) =
            if (transactions > 0) occurrences.toDouble() / transactions.toDouble() else 0.0

    override fun findFrequentItemSets(iterable: Iterable<Transaction<ItemType>>,
                                      minSupport: Double): Map<Int, TransactionalItemSet<ItemType>> {
        ensureAtLeast(minSupport, 0.0, "The minimum support must be at least 0")
        ensureAtMaximum(minSupport, 1.0, "The minimum support must be at maximum 1")
        LOGGER.debug("Searching for frequent item sets")
        val frequentItemSets = HashMap<Int, TransactionalItemSet<ItemType>>()
        var k = 1
        val (candidates, transactionCount) = generateInitialItemSets(iterable)
        var currentCandidates = candidates!!

        while (!currentCandidates.isEmpty()) {
            LOGGER.trace("k = {}", k)
            LOGGER.trace("C_{} = {}", k, currentCandidates)
            val frequentCandidates = filterFrequentItemSets(currentCandidates, transactionCount!!,
                    k, minSupport)
            LOGGER.trace("S_{} = {}", k, frequentCandidates)
            currentCandidates = combineItemSets(frequentCandidates, k)
            frequentCandidates.forEach { x -> frequentItemSets[x.hashCode()] = x }
            k++
        }

        LOGGER.debug("Found {} frequent item sets", frequentItemSets.size)
        LOGGER.debug("Frequent item sets = {}",
                FrequentItemSets.formatFrequentItemSets(frequentItemSets.values))
        return frequentItemSets
    }

}
